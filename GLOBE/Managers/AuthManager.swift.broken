import Foundation
import Supabase
import SwiftUI
import Combine

// MARK: - Database Insert Structures
// Note: ProfileInsert moved to SharedModels.swift

// MARK: - Auth Errors

// Note: AuthError moved to SharedModels.swift

// Note: AppUser moved to SharedModels.swift

@MainActor
class AuthManager: ObservableObject {
    static let shared = AuthManager()
    
    @Published var currentUser: AppUser?
    @Published var isAuthenticated = false
    @Published var isLoading = false
    
    // MARK: - Security Configuration
    
    /// セキュアロガー
    private let logger = Logger.shared
    /// デバッグロガー

    
    /// 最大ログイン試行回数
    private let maxLoginAttempts = 5
    
    /// アカウントロック期間（15分）
    private let lockoutDuration: TimeInterval = 900
    
    /// ログイン試行回数の追跡
    private var loginAttempts: [String: (count: Int, lastAttempt: Date)] = [:]
    
    private init() {
        setupSecurityConfiguration()
        
        // 初期化時は現在のセッションをチェック
        Task {
            await checkCurrentUser()
        }
    }
    
    private func setupSecurityConfiguration() {
        #if DEBUG
        SecureConfig.shared.initializeForDevelopment()
        #endif
        logger.info("Auth event logged")
            throw AuthError.invalidInput("有効なメールアドレスを入力してください")
        }
        
        let passwordValidation = InputValidator.validatePassword(password)
        guard passwordValidation.isValid else {
            logger.info("Auth event logged")
            throw AuthError.invalidInput("ユーザー名は3-20文字で、英字、数字、アンダースコアのみ使用できます")
        }
        
        isLoading = true
        defer { isLoading = false }
        
        logger.info("Auth event logged")
            throw AuthError.unknown(error.localizedDescription)
        }
    }
    
    func signIn(email: String, password: String) async throws {
        // 入力検証
        let emailValidation = InputValidator.validateEmail(email)
        guard emailValidation.isValid, let validEmail = emailValidation.value else {
            logger.info("Auth event logged")
            throw AuthError.invalidInput("有効なメールアドレスを入力してください")
        }
        
        guard !password.isEmpty else {
            throw AuthError.invalidInput("パスワードを入力してください")
        }
        
        // レート制限チェック
        try checkRateLimit(for: validEmail)
        
        isLoading = true
        defer { isLoading = false }
        
        logger.info("Auth event logged")
            throw AuthError.unknown("パスワードリセットメールの送信に失敗しました")
        }
    }
    
    func signOut() async throws {
        isLoading = true
        defer { isLoading = false }
        
        logger.info("Auth event logged")
            // エラーが発生してもローカル状態はクリア
            await clearUserSession()
            throw AuthError.unknown(error.localizedDescription)
        }
        #endif
    }
    
    // MARK: - Session Management
    
    /// ユーザーセッションをクリア（関連サービスも含む）
    private func clearUserSession() async {
        currentUser = nil
        isAuthenticated = false
        
        // ログイン試行回数もクリア
        loginAttempts.removeAll()
        
        // 関連サービスのクリアも必要に応じて追加
        // PostManager.shared.clearUserData()
        // LikeService.shared.clearUserData()
        // CommentService.shared.clearUserData()
        
        logger.info("Auth event logged")
                    throw AuthError.rateLimitExceeded(remainingTime)
                } else {
                    // ロック期間終了、リセット
                    loginAttempts.removeValue(forKey: email)
                }
            }
        }
    }
    
    /// 失敗したログイン試行を記録
    private func recordFailedLoginAttempt(for email: String) {
        let now = Date()
        
        if var attempt = loginAttempts[email] {
            attempt.count += 1
            attempt.lastAttempt = now
            loginAttempts[email] = attempt
        } else {
            loginAttempts[email] = (count: 1, lastAttempt: now)
        }
        
        logger.info("Auth event logged")
    }
    
    /// ログイン試行回数をリセット
    private func resetLoginAttempts(for email: String) {
        loginAttempts.removeValue(forKey: email)
        logger.info("Auth event logged")
            await clearUserSession()
            return false
        }
    }
    
    /// 強制的なセッション更新
    func forceSessionRefresh() async throws {
        guard isAuthenticated else {
            throw AuthError.userNotAuthenticated
        }
        
        logger.info("Auth event logged")
            await clearUserSession()
            throw AuthError.unknown("Session refresh failed")
        }
    }
    
    // MARK: - Password Security
    
    /// パスワード強度チェック（詳細版）
    func validatePasswordStrength(_ password: String) -> (isValid: Bool, score: Int, feedback: [String]) {
        var score = 0
        var feedback: [String] = []
        
        // 長さチェック
        if password.count >= 8 {
            score += 1
        } else {
            feedback.append("パスワードは8文字以上にしてください")
        }
        
        if password.count >= 12 {
            score += 1
        }
        
        // 文字種チェック
        if password.rangeOfCharacter(from: .lowercaseLetters) != nil {
            score += 1
        } else {
            feedback.append("小文字を含めてください")
        }
        
        if password.rangeOfCharacter(from: .uppercaseLetters) != nil {
            score += 1
        } else {
            feedback.append("大文字を含めてください")
        }
        
        if password.rangeOfCharacter(from: .decimalDigits) != nil {
            score += 1
        } else {
            feedback.append("数字を含めてください")
        }
        
        if password.rangeOfCharacter(from: CharacterSet(charactersIn: "!@#$%^&*()_+-=[]{}|;:,.<>?")) != nil {
            score += 1
        } else {
            feedback.append("記号を含めてください")
        }
        
        // よくあるパスワードパターンのチェック
        let commonPatterns = ["password", "123456", "qwerty", "abc123", "admin", "test"]
        if commonPatterns.contains(where: { password.lowercased().contains($0) }) {
            score -= 2
            feedback.append("よくあるパスワードパターンは避けてください")
        }
        
        // 連続文字のチェック
        if hasSequentialCharacters(password) {
            score -= 1
            feedback.append("連続した文字列は避けてください")
        }
        
        return (isValid: score >= 4, score: max(0, score), feedback: feedback)
    }
    
    private func hasSequentialCharacters(_ password: String) -> Bool {
        let chars = Array(password.lowercased())
        for i in 0..<chars.count-2 {
            let char1 = chars[i].asciiValue ?? 0
            let char2 = chars[i+1].asciiValue ?? 0
            let char3 = chars[i+2].asciiValue ?? 0
            
            if char2 == char1 + 1 && char3 == char2 + 1 {
                return true
            }
        }
        return false
    }
    
    // MARK: - Device Security
    
    /// デバイス情報の取得とセキュリティチェック
    func getDeviceSecurityInfo() -> [String: String] {
        var deviceInfo: [String: String] = [:]
        
        // デバイス基本情報
        deviceInfo["device_model"] = UIDevice.current.model
        deviceInfo["system_name"] = UIDevice.current.systemName
        deviceInfo["system_version"] = UIDevice.current.systemVersion
        deviceInfo["app_version"] = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? "unknown"
        
        // セキュリティ関連情報
        #if targetEnvironment(simulator)
        deviceInfo["is_simulator"] = "true"
        #else
        deviceInfo["is_simulator"] = "false"
        #endif
        
        // Jailbreak チェック（基本的な実装）
        deviceInfo["is_jailbroken"] = isJailbroken() ? "true" : "false"
        
        return deviceInfo
    }
    
    private func isJailbroken() -> Bool {
        #if targetEnvironment(simulator)
        return false
        #else
        // 一般的なJailbreakファイル/パスの存在チェック
        let jailbreakPaths = [
            "/Applications/Cydia.app",
            "/Library/MobileSubstrate/MobileSubstrate.dylib",
            "/bin/bash",
            "/usr/sbin/sshd",
            "/etc/apt"
        ]
        
        for path in jailbreakPaths {
            if FileManager.default.fileExists(atPath: path) {
                return true
            }
        }
        
        // Write test - Jailbrokenデバイスでは通常書き込めない場所に書き込めるかテスト
        let testString = "jailbreak_test"
        do {
            try testString.write(toFile: "/private/test.txt", atomically: true, encoding: .utf8)
            try? FileManager.default.removeItem(atPath: "/private/test.txt")
            return true
        } catch {
            // 書き込めない = 正常
        }
        
        return false
        #endif
    }
    
    // MARK: - Enhanced Error Handling
    
    /// セキュリティイベントレポート
    func reportSecurityEvent(_ event: String, severity: SecuritySeverity = .medium, details: [String: Any] = [:]) {
        let deviceInfo = getDeviceSecurityInfo()
        var eventDetails = details
        eventDetails["device_info"] = deviceInfo
        eventDetails["timestamp"] = ISO8601DateFormatter().string(from: Date())
        eventDetails["user_id"] = currentUser?.id ?? "anonymous"
        
        logger.info("Auth event logged") {
        // 重要度の高いセキュリティイベントの処理
        // 実装例：
        // - 自動ログアウト
        // - 管理者への通知
        // - 一時的なアカウント制限
        
        logger.info("HIGH_SEVERITY_SECURITY_EVENT", details: details)
        
        // Jailbreakが検出された場合など、自動ログアウト
        if event.contains("jailbreak") || event.contains("unauthorized_access") {
            Task {
                try? await signOut()
            }
        }
    }
    
    // MARK: - User Profile Management
    
    /// Supabaseにユーザープロフィールを作成
    private func createUserProfile(userId: String, username: String, email: String) async {
        logger.info("Creating user profile for userId: \(userId)")
        
        do {
            guard let userUUID = UUID(uuidString: userId) else {
                logger.info("Invalid user ID format")
                return
            }
            
            let profileData = ProfileInsert(
                id: userUUID,
                username: username,
                displayName: username
            )
            
            let profileDict: [String: AnyJSON] = [
                "id": AnyJSON.string(profileData.id.uuidString),
                "username": AnyJSON.string(profileData.username),
                "display_name": AnyJSON.string(profileData.displayName)
            ]
            
            _ = try await supabase
                .from("profiles")
                .insert(profileDict)
                .execute()
            
            logger.info("User profile created successfully")
            logger.info("Profile data - userId: \(userId), username: \(username), email: \(email)")
            
        } catch {
            // プロフィール作成に失敗してもアカウント作成は成功させる
            logger.info("Failed to create user profile: \(error.localizedDescription)")
            logger.info("User can still use the app with authentication only")
        }
    }
}

enum SecuritySeverity {
    case low, medium, high, critical
}
