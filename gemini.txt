現在のコードは、ズームレベルと密集度を段階的な閾値（if/elseやswitch）で処理しているため、特定のズームレベルや投稿数を境にカードが突然現れたり消えたりする、カクカクとした不自然な表示になりがちです。

ここで提案するのは、対数関数を利用して、ズームレベルと投稿密度を**滑らか（連続的）**に閾値に反映させる方法です。これにより、ユーザーのズーム操作に応じて、カードが自然に表示・非表示されるようになります。

✨ 新しい計算方法のポイント
パフォーマンスの向上:
各投稿ごとに周辺の密度を計算するのではなく、現在画面に表示されている領域内の投稿数を「密度」として一度だけ計算します。これにより、計算量が大幅に削減されます。

滑らかな表示制御:
対数関数を使い、ズームレベルと密度から「表示スコアの閾値」を動的に、かつ滑らかに算出します。これにより、「拡大すると徐々にカードが増え、縮小すると重要なものだけが残る」という自然な体験を実現します。

チューニングの容易さ:
計算に使う係数や最大・最小値を定数としてまとめておくことで、アプリの使い心地に合わせた微調整が簡単になります。

提案するSwiftコード
以下に、改善されたロジックを組み込んだMapViewModelの例を示します。既存のコードと差し替えて、または参考にして実装してみてください。

Swift

import SwiftUI
import MapKit

// PostモデルとCLLocationCoordinate2Dの距離計算関数は既存のものを使用
// struct Post { ... }
// func distanceBetweenCoordinates(_ a: CLLocationCoordinate2D, _ b: CLLocationCoordinate2D) -> Double { ... }

class MapViewModel: ObservableObject {
    @Published var region = MKCoordinateRegion()
    @Published var allPosts: [Post] = [] // サーバーなどから取得した全投稿
    @Published var visiblePosts: [Post] = [] // 地図に実際に表示する投稿

    // MARK: - Configuration Constants (ここで挙動を調整)
    
    /// 密度計算で考慮する画面内の最大投稿数。これ以上は密度が最大として扱われる。
    private let MAX_DENSITY_COUNT = 100.0
    
    /// 閾値計算に使うズームレベル（latitudeDelta）の最小値（最も拡大した状態）
    private let MIN_ZOOM_SPAN = 0.002
    
    /// 閾値計算に使うズームレベル（latitudeDelta）の最大値（最も縮小した状態）
    private let MAX_ZOOM_SPAN = 20.0
    
    /// 投稿スコアが超えるべき閾値の最小値
    private let MIN_THRESHOLD = 0.1
    
    /// 投稿スコアが超えるべき閾値の最大値
    private let MAX_THRESHOLD = 1.0
    
    /// 閾値計算におけるズームレベルと密度の影響度（合計で1.0になるように）
    private let ZOOM_WEIGHT = 0.6 // ズームレベルの重要度
    private let DENSITY_WEIGHT = 0.4 // 密度の重要度

    // 地図の表示領域が変更されたときに呼び出す
    func onRegionChanged() {
        updateVisiblePosts()
    }

    // MARK: - Density-Based Visibility Control (Improved Logic)
    
    private func updateVisiblePosts() {
        let currentZoomLevel = region.span.latitudeDelta
        
        // 1. パフォーマンスのため、まず画面内の投稿のみをフィルタリング
        let postsInRegion = allPosts.filter { isCoordinate($0.location, in: region) }
        let density = postsInRegion.count

        // 2. ズームレベルと密度から動的な閾値を計算
        let threshold = calculateDynamicThreshold(zoomLevel: currentZoomLevel, density: density)
        
        // 3. スコアが閾値を超えた投稿のみを表示対象とする
        // さらに、密集地ではスコアが高い順に表示件数を制限しても良い
        visiblePosts = postsInRegion.filter { post in
            calculatePostScore(post) >= threshold
        }
    }

    /// ズームレベルと密度から、表示/非表示の閾値を動的に計算する
    private func calculateDynamicThreshold(zoomLevel: Double, density: Int) -> Double {
        // --- ズーム係数を計算 (0.0: 最大拡大 ~ 1.0: 最大縮小) ---
        // 対数スケールでズームレベルを正規化し、急激な変化を防ぐ
        let clampedZoom = max(MIN_ZOOM_SPAN, min(MAX_ZOOM_SPAN, zoomLevel))
        let logMinZoom = log(MIN_ZOOM_SPAN)
        let logMaxZoom = log(MAX_ZOOM_SPAN)
        let zoomFactor = (log(clampedZoom) - logMinZoom) / (logMaxZoom - logMinZoom)

        // --- 密度係数を計算 (0.0: 低密度 ~ 1.0: 高密度) ---
        let densityFactor = min(1.0, Double(density) / MAX_DENSITY_COUNT)
        
        // --- 最終的な閾値を計算 ---
        // ズーム係数と密度係数を重み付けして合成
        let combinedFactor = (zoomFactor * ZOOM_WEIGHT) + (densityFactor * DENSITY_WEIGHT)
        
        // 最終的な閾値を MIN_THRESHOLD と MAX_THRESHOLD の間にマッピング
        let threshold = MIN_THRESHOLD + (MAX_THRESHOLD - MIN_THRESHOLD) * combinedFactor
        
        return threshold
    }
    
    /// 投稿の重要度を計算する（この部分は既存のロジックを流用・改善）
    private func calculatePostScore(_ post: Post) -> Double {
        var score: Double = 0.0

        // 新しい投稿ほど高スコア（24時間以内は優遇）
        let ageHours = Date().timeIntervalSince(post.createdAt) / 3600
        if ageHours <= 24 {
            score += 0.5
        } else if ageHours <= 168 { // 1週間以内
            score += 0.3
        }

        // 画像付き投稿は優遇
        if post.imageUrl != nil { // imageDataのチェックも必要であれば追加
            score += 0.2
        }

        // 基本スコア
        score += 0.2
        
        // スコアが1.0を超えないようにクランプ（上限を設定）
        return min(1.0, score)
    }
    
    // 指定した座標が領域内に含まれるかを判定するヘルパー
    private func isCoordinate(_ coordinate: CLLocationCoordinate2D, in region: MKCoordinateRegion) -> Bool {
        let center = region.center
        let span = region.span
        
        let latitudinalMeters = region.span.latitudeDelta * 111320.0 / 2.0
        let longitudinalMeters = region.span.longitudeDelta * 111320.0 * cos(region.center.latitude * .pi / 180.0) / 2.0
        
        let maxLat = center.latitude + span.latitudeDelta / 2
        let minLat = center.latitude - span.latitudeDelta / 2
        let maxLon = center.longitude + span.longitudeDelta / 2
        let minLon = center.longitude - span.longitudeDelta / 2
        
        return coordinate.latitude >= minLat && coordinate.latitude <= maxLat &&
               coordinate.longitude >= minLon && coordinate.longitude <= maxLon
    }
}
⚙️ 使い方
MapViewModelのインスタンスをViewで管理します。

地図が動くたびに（例えばonRegionChangeのようなモディファイアで）、viewModel.onRegionChanged()を呼び出します。

ViewはviewModel.visiblePostsを監視し、この配列に含まれる投稿のみを地図上に表示します。

このロジックにより、都市部で地図を縮小すると人気の投稿だけが表示され、拡大するにつれて新しい投稿や小さな投稿が滑らかに表示される、といった直感的で快適なユーザー体験を提供できるはずです。

ぜひ、Configuration Constantsの値を調整して、あなたのアプリに最適な表示バランスを見つけてみてください。